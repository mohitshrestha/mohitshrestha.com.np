{
  "hash": "8d83c5877e758f8b32ae7629ba2f8ca4",
  "result": {
    "markdown": "---\ntitle: \"Data Wrangling 2.0 with R\"\ndescription: |\n  Now this week is data wrangling 2.0 with R, where we'll be taking a step further into wrangling and look at data structuring where we will be using more techniques like joining, transposing to analyze the data better.\ndate: 2019-07-29\ncategories: [MSBA, DataScience, Data Analytics, R, Data Wrangling, Dplyr]\nimage: media/figure-1.png\ncode-fold: false\ndraft: false\ncitation:\n  type: post-weblog\neditor: \n  markdown: \n    wrap: sentence\n---\n\n\nWe've been studying R for two weeks now, and so far we have studied the basics -- analyzing the data with simple plotting- creating histogram, scatter plot.\n\nAnd now this week is data wrangling 2.0 with R, where we'll be taking a step further into wrangling and look at data structuring where we will be using more techniques like joining, transposing to analyze the data better.\n\n\n::: {.cell layout-align=\"right\"}\n::: {.cell-output-display}\n![](media/figure-1.png){fig-align='right' width=30%}\n:::\n:::\n\n\nFirst we looked at how to filter NAs, how to convert a character into a numeric data, convert date integer/character format into Date format using lubridate package, which is a R package that basically makes it easier to process any date related tasks.\n\nIn today's blog, I'll just make a note of some of these techniques that I thought would be most helpful.\n\n-   Data wrangling **with DPLYR**\n\n    -   inner join\n\n    -   full join\n\n    -   bind rows and bind column\n\n    -   union all\n\n    -   union\n\n-   Data wrangling **with SQL**\n\n    -   SetDiff\n\n-   Data wrangling **with Tidy R**\n\n    -   gather\n\n    -   spread\n\nJOINs statement in R are very similar to PROC SQL in SAS, but I found writing Join statement in R much easier and straight forward.\n\nThe most used technique of joining two datasets is using the function **inner join** which returns all observations in table_A and table_B, where the keys are equal, which is defined in the by statement.\nIf we don't specify the columns that we want to join by, by default, it will take the column names that match.\n\n![Inner Join](media/inner_join.png){fig-alt=\"Inner Join\" fig-align=\"center\" width=\"450\"}\n\n**Full join** is another useful technique where it selects all matching and non-matching rows, and brings the records from all of the tables.\nI think this will be very useful when we are trying to find things that don't match up.\n\n![Full Join](media/full_join.png){fig-alt=\"Full Join\" fig-align=\"center\" width=\"450\"}\n\nBut what happens when we don't have matching columns?\nWe just use DPLYR and specify a vector in the by statement:\n\n**by = c(\"x\" = \"x2\", \"y\" = \"y2\")**\n\nHere, x will be coming from Table 1, and x2 will be coming from Table 2.\nThey don't have to be the same name, but they have to be the same type.\n\n![https://dplyr.tidyverse.org/reference/join.html](media/common_join_gotchas.png){fig-alt=\"Common Join Gotchas!\" fig-align=\"center\" width=\"450\"}\n\nThe other thing we learned is how to append rows together and bind columns by using functions **bind_rows** and **bind_cols**.\nThey are pretty similar in terms of what they do.\nBind rows just appends the tables together, and bind columns just puts the two tables together without the join.\nIt may look like it joins the tables, but it's not matching the keys.\nAlso, in bind column, it just looks at the first column of first table.\nSo in the example below, bind column just takes the observation data in COL_A of Table A.\n\n![Bind Rows and Bind Cols](media/bind_rows_bind_cols.png){fig-alt=\"Bind Rows and Bind Cols\" fig-align=\"center\" width=\"450\"}\n\nSo, the next function that is similar to bind_rows is **union_all**.\nUnion also bind rows, but it doesn't do sort, so we'll just end up with a record once Table A and Table B are put together.\n\n![Union all](media/union_all.png){fig-alt=\"Union all\" fig-align=\"center\" width=\"450\"}\n\nThere's another function **union** which is similar to union_all, where it appends the records with a sort distinct and returns the unique set of rows from Table A and B\n\n![Union](media/union.png){fig-alt=\"Union\" fig-align=\"center\" width=\"450\"}\n\nOne of the other things that I think would be very helpful is **SetDiff** as it returns the rows that don't match.\nThere are times when we want to see what didn't match, so in those cases SetDiff would be super helpful.\n\n![Setdiff](media/setdiff.png){fig-alt=\"Setdiff\" fig-align=\"center\" width=\"450\"}\n\nWe also learnt about data tidying, which is similar to transpose but a lot more powerful, where we have\n\n-   **gather** which allows us to take multiple columns and gathers them into key-value pairs and flips them into rows\n\n-   **spread** which takes two columns (key & value) and spreads in to multiple columns and makes rows into columns\n\n![Gather](media/gather.png){fig-alt=\"Gather\" fig-align=\"center\" width=\"450\"}\n\n![Spread](media/spread.png){fig-alt=\"Spread\" fig-align=\"center\" width=\"450\"}\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}